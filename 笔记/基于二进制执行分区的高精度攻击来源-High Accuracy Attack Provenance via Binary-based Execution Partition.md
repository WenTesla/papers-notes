# 基于二进制执行分区的高精度攻击来源-High Accuracy Attack Provenance via Binary-based Execution Partition

在本文中，我们提出了一种**用于二进制程序的高效、无依赖爆炸日志记录的新方案**，称为BEEP。**BEEP基于一种新的、更细粒度的主题类型，称为单元**。更具体地说，单元是处理特定对象（例如，电子邮件消息、URL或请求）的进程的执行段。



## 贡献

降低基于日志的攻击溯源分析中执行主体的粒度。BEEP不是将进程作为主体，而是将**一个进程的执行**划分为各个单元，以有效地缓解依赖关系的扩散。

我们进行了一项实证研究，以说明基于过程的日志记录会导致依赖爆炸，并证实许多程序在执行过程中存在单元。

提出了一种新技术来逆向工程一些必要的循环，这种循环的迭代蕴含了单元(units)的自然边界，而且内存访问指令(memory access instructions)也会引起单元之间的有因果关系的工作流，然后在这些地方检测应用**程序二进制文件**，以记录此类事件。

提出了一种日志分析算法，对系统日志和我们的日志进行连贯的推理，来为一个攻击准确地构建因果依赖图





## 例子

<img src="https://cdn.xljsci.com/literature/164192057/page3/iivq9g.png" alt="img"  />

下面的颗粒度更细



我们的方法概述： 我们建议**使用 BEEP 来促进更准确的因果关系分析，并使用更细粒度的主题：单位**。BEEP 将流程的执行动态划分为称为单元的自主执行段。单元本质上是事件处理循环的迭代。对于由外部事件驱动的程序，其执行由此类迭代和迭代直接或间接调用的函数主导。另一方面，单位也不是完全独立的。因此，我们通过观察内存依赖关系来检测单元之间的因果关系。

> 例如，在 Firefox 中，事件（如连接打开事件、页面加载事件或页面呈现事件）的处理是通过循环的迭代来执行的。

迭代（即单元）可以在工作队列中进一步发布更多延续任务，这些任务由其他循环迭代（即单元）处理。

为了帮助识别单元，BEEP 首先通过在一组训练运行上运行二进制文件来自动检测 firefox 二进制文件中的事件处理循环以及导致单元之间依赖关系的指令。然后，它会在识别的指令处检测二进制文件，以在生产运行期间记录单元边界和单元依赖关系。通过分析标准审核日志和我们的日志来生成因果关系图。

在生成的因果图中，一个进程被分解为许多自治单元，每个单元访问的对象（例如，文件、套接字）都有相应的分区，从而避免了本节前面演示的依赖性爆炸。



- **场景**：用户点击邮件中的恶意 URL，Firefox 需处理 “打开链接”“加载页面”“下载文件” 等事件。
- 单元定义
  - **Unit 1**：Firefox 中处理 “连接打开” 事件的循环迭代，负责解析 URL 并生成下载任务。
  - **Unit 2**：处理 “页面加载” 事件的循环迭代，触发文件下载动作。
  - **Unit 3**：工作队列处理循环的迭代，从队列中读取下载任务并执行文件写入。

### 单元

前提：在大多数情况下，我们观察到事件处理循环位于应用程序代码内部。在某些情况下，我们发现事件循环可以驻留在特殊库中

