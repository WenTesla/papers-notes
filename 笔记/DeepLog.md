# DeepLog：通过深度学习从系统日志中检测和诊断异常

## 摘要

我们提出DeepLog，一种利用长短期记忆（**LSTM**）的深度神经网络模型，**将系统日志建模为自然语言序列。**这允许DeepLog从正常执行中自动学习日志模式，并在日志模式偏离正常执行下从日志数据训练的模型时检测异常。此外，我们演示了如何以在线方式增量更新DeepLog模型，以便它能够随着时间的推移适应新的日志模式。此外，DeepLog从底层系统日志构建工作流，以便一旦检测到异常，用户可以诊断检测到的异常并有效地执行根本原因分析

## 结构

三个部分：

- **日志密钥异常检测模型**
- **参数值异常检测模型**
- **诊断检测到的异常的工作流模型。**

![img](https://cdn.xljsci.com/literature/134331373/page3/agau7i.png)

### 训练阶段



DeepLog的训练数据是来自**系统正常执行路径的日志条目**。**每个日志条目会被解析为一个日志键(log key)和一个参数值向量(parameter value vector)**。从训练日志文件中解析出的日志键序列，会被DeepLog用于训练日志键异常检测模型，以及构建系统执行工作流模型，以便进行诊断。对于每个不同的键，DeepLog还会训练并维护一个模型，该模型通过键k的参数值向量序列进行训练，用于检测由这些度量值所反映的系统性能异常。

> 对于日志条目 e =“Took 10 seconds to build instance”，其日志键 k =“Took * seconds to build instance.”

![日志解析](https://cdn.xljsci.com/literature/134331373/page3/2enzbd.png)

### 检测阶段

新到达的日志条目被解析为**一个日志键和一个参数值向量**。

使用**日志键**异常检测模型用于检查传入的日志键是否正常。

如果正常，DeepLog会进一步使用**针对该日志键的参数值异常检测模型来检查参数值向量**。如果日志键或其参数值向量被预测为异常，则新条目将被标记为异常。

最后，如果该条目被标记为异常，DeepLog的工作流模型会为用户提供语义信息以诊断异常。

执行模式可能会随时间变化，或者未包含在原始训练数据中。DeepLog还提供了收集用户反馈的选项。如果用户报告检测到的异常为误报，DeepLog可以将其作为标记记录，以增量方式更新其模型，从而纳入并适应新的模式。



### 威胁模型

- 导致系统执行不当行为并因此导致系统日志中异常模式的攻击。 例如Dos，BROP
- 由于系统监控服务的日志记录活动，可能在系统日志中留下痕迹的攻击。 



> Blind Return - Oriented Programming (BROP) 是一种复杂且强大的二进制漏洞利用技术。它是在传统的 Return - Oriented Programming (ROP) 基础上发展而来的，主要用于在缺乏足够的调试信息和代码可见性的情况下，对软件中的漏洞进行利用。
>
> - 首先，攻击者需要找到一个可以触发的漏洞，比如缓冲区溢出漏洞。通过向目标程序发送大量不同长度和内容的输入，攻击者观察程序的反应，例如程序是否崩溃、在什么情况下崩溃等。这就像是在黑暗中摸索，通过不断地试探来了解目标程序的一些基本特性。
> - 当程序崩溃时，攻击者可以根据崩溃信息（如返回地址的值、寄存器的值等）来推断程序的内存布局。例如，如果程序因为访问非法内存地址而崩溃，攻击者可以通过分析这个非法地址来猜测栈的位置或者其他重要的内存区域的大致位置。

## 异常检测

### 执行路径异常

<img src="https://cdn.xljsci.com/literature/134331373/page4/xotni6.png" alt="日志密钥异常检测模型概述。" style="zoom: 67%;" />

输入是最近的 h 个日志键，一直到 m~t−1~ ，也就是 *w*={m~t−h~*,…,*m~t−2~,m~t−1~} 。这意味着模型会基于过去的 h 个日志键来进行预测。

然后，DeepLog 模型会处理这些输入的日志键序列，并输出在给定这些输入的最近序列的情况下，下一个日志键 m~t~是某个特定的 k~i~（k~i~ 属于日志键集合 *K*，其中 *i*=1,…,*n*）的条件概率 Pr(*mt*=*ki*∣*w*) 

### 参数值与性能异常

DeepLog通过将每个参数值向量序列（针对一个日志键）视为单独的时间序列，来训练一个参数值异常检测模型。

输入。每个时间步的输入仅仅是该时间戳的参数值向量。我们通过训练数据中来自相同参数位置的所有值的平均值和标准差对每个向量中的值进行归一化。

输出。输出是一个实值向量，作为对下一个参数值向量的预测，该预测基于近期历史中的一系列参数值向量。

### 在线更新

为了实现这一点，DeepLog 提供了一种让用户提供反馈的机制。这使得 DeepLog 能够利用误报情况来调整其权重。例如，假设 h=3，最近的历史序列是 {k₁, k₂, k₃}，并且 DeepLog 预测下一个日志键是 k₁，概率为 1，但实际的下一个日志键值是 k₂，这会被标记为异常。如果用户报告这是一个误报，DeepLog 能够使用输入 - 输出对 {k₁, k₂, k₃ → k₂} 来更新其模型的权重，以学习这种新模式。这样，下次给定历史序列 {k₁, k₂, k₃} 时，DeepLog 可以输出 k₁和 k₂，并带有更新后的概率。



### 问题

![img](https://cdn.xljsci.com/literature/134331373/page7/4g47zy.png)

考虑一个日志序列“54→57”，假设预测的概率分布是“{18: 0.8, 56: 0.2}”，这意味着下一步可能是“18”或“56”。这种模糊性可能是由于使用的历史序列长度不足造成的。例如，如果两个任务共享相同的工作流片段“54→57”，第一个任务有一个模式“18→54→57→18”，该模式在80% 的时间内执行，而第二个任务有一个模式\(31→ 54 → 57 →56，该模式在20% 的时间内执行。这将导致模型在给定序列“54→57”时预测“{18: 0.8, 56: 0.2}”。	

### 基于密度的聚类

#### 日志键分离（Log key separation）

核心思想是：同一任务的日志键通常会密集共现，而不同任务的日志键共现频率较低。通过定义日志键间的距离和共现概率，实现任务分离。

太难了，难以理解

## 评估

数据集：HDFS和OpenSatack

![img](https://cdn.xljsci.com/literature/134331373/page9/7g5t5p.png)

结果

![img](https://cdn.xljsci.com/literature/134331373/page10/ykw0it.png)

![img](https://cdn.xljsci.com/literature/134331373/page10/446byd.png)

![img](https://cdn.xljsci.com/literature/134331373/page11/3sa73i.png)