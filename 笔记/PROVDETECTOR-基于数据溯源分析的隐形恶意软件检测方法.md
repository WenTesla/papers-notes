# PROVDETECTOR-基于数据溯源分析的隐形恶意软件检测方法

## 总结

PROVDETECTOR 基于内核级数据溯源监控，遵循不依赖静态文件指标、能检测可信程序异常行为、轻量化的原则。

其工作流程包括四个阶段：构建溯源图、提取表示（选择因果路径）、嵌入（将路径转为数值向量）、异常检测（使用 LOF 算法）。为解决边际偏差检测和模型构建可扩展性的挑战，采用了将溯源图分解为因果路径、基于稀有度选择路径等方法。

## 挑战

**C1：检测微小偏差**。

基于伪装的隐秘恶意软件往往其恶意行为仅产生微小偏差，因此它能够融入良性程序的正常行为中。例如，一些隐秘恶意软件仅创建另一个线程，将其恶意逻辑植入到目标进程中。当目标进程仍在执行其原始任务时，注入的恶意逻辑也会与之并行运行。

因此，PROVDETECTOR需要准确识别并隔离那些与程序良性行为显著偏离的微小异常事件。传统的模型学习很可能将这一小部分行为视为可忽略的背景噪声而不予理会，从而导致对恶意行为的误分类。 

为应对第一个挑战，**PROVDETECTOR将起源图分解为因果路径，并将因果路径作为检测的基本组件（§V-C）**。这一决策的依据在于，隐秘恶意软件的行为具有逻辑联系和因果依赖关系[60]、[56]。通过将因果路径用作检测组件，PROVDETECTOR能够将起源图中的良性部分与恶意部分隔离开来。

**C2：可扩展的模型构建。**

随着时间的推移，溯源图的规模迅速增长，连接了大量的系统对象。对于一种以溯源数据为输入并为每个进程构建模型的基于溯源的方法而言，即使在一个拥有数百台主机的小型组织中，也常见到每个终端主机报告的系统事件会带来巨大的数据处理压力。

虽然基于单跳关系的简单建模[39]能够扩展以处理大规模的溯源图，但单跳关系无法捕捉上下文因果关系并将其嵌入模型中。然而，基于多跳跃关系（例如，n元语法[33]或子图匹配[40]）会带来巨大的计算和存储压力，使得任何实际部署都不可行。

为应对这第二个挑战，**PROVDETECTOR仅处理溯源图中可疑的部分**。这是通过一种新颖的路径选择算法（§V - C1）实现的，该算法仅选择溯源图中前K条最不常见的因果路径。我们的观点是，程序的大多数实例所共有的溯源图部分不太可能是恶意的。因此，我们只需要关注在其他实例中不常见的部分。利用这种路径选择算法，PROVDETECTOR可以减少大部分训练和检测工作量。

## 贡献

- 我们设计并实现了PROVDETECTOR，这是一个基于溯源的系统，用于检测采用伪装技术的隐秘恶意软件。
- 为保证较高的检测准确率和效率，我们提出了一种新颖的路径选择算法，以识别进程起源图中的潜在恶意部分。
- 我们设计了一种新颖的神经嵌入和机器学习流程，该流程能自动为每个程序构建行为画像，并识别异常进程。
- 我们使用真实恶意软件进行了系统评估，以证明PROVDETECTOR的有效性。
- 我们通过多项可解释性研究进一步说明了其有效性。



## 举例

<img src="https://cdn.xljsci.com/literature/166634759/page4/ywwnkq.png" alt="图2：使用溯源图对Microsoft Word（winword.exe）的良性进程实例和恶意进程实例的行为差异进行的说明。" style="zoom:67%;" />

图2展示了一次隐蔽攻击的示例，以及微软Word（winword.exe）两个进程实例在有攻击和无攻击情况下的溯源图。在图2a中，我们展示了微软Word良性实例的溯源图。一个良性的微软Word进程通常会读取由其他程序或其自身创建的多种类型的文件（如dat、doc、css），并写入新文件（如doc、txt、png）。创建的文件也会被其他程序读取，例如Outlook电子邮件客户端（如作为附件发送）。当用户点击doc文件中的URL时，它还可以启动其他程序，如Internet Explorer（iexplore.exe）。相比之下，图2b展示了微软Word恶意实例的溯源图，该恶意实例用于图1所示的基于DDE脚本的攻击。请注意，我们用红色箭头突出显示了关键攻击路径。与良性实例类似，这个恶意的微软Word实例也会读取和写入不同类型的 

![img](https://cdn.xljsci.com/literature/166634759/page6/1yj4co.png)

## 设计

- PROVDETECTOR是一种基于异常检测的技术，仅从良性数据中学习。
- PROVDETECTOR 使用因果路径（即具有因果依赖关系的系统事件的有序序列）作为出处图中的检测特征。
- PROVDETECTOR仅学习出处图的一部分因果路径。

PROVDETECTOR有两种模式：训练模式和检测模式。检测模式的工作流程已在上文描述。训练模式的工作流程与之类似。唯一的区别在于，PROVDETECTOR不是查询新颖性/异常检测器，而是使用嵌入向量来训练检测器（即为应用程序构建正常配置文件）。

![img](https://cdn.xljsci.com/literature/166634759/page6/7132ez.png)

### 构建图

**图构建**：针对每个需要监测的进程实例，PROVDETECTOR 依据数据库中存储的数据，构建其溯源图 *G*(*p*)=<*V*,*E*>。其中，节点 *V* 为系统实体（进程、文件或套接字，如下图所示），其标签是相应的属性（标签为关系或者时间戳）；边 *E* 为系统事件，标签为关系和时间戳 。构建过程从代表进程的节点 *v*=*p* 开始，若边 *e* 的源节点 *src* 或目标节点 *d**s**t* 已在图中，则将该边及其相关节点添加到图中。

<img src="https://cdn.xljsci.com/literature/166634759/page4/y6e5kp.png" alt="img" style="zoom: 67%;" />

### 提取

**表示提取**：从构建好的溯源图中提取用于区分良性和恶意行为的特征。采用基于稀有度的路径选择方法，只选取图中 K 个最不常见的因果路径。因果路径指系统事件的有序序列 e~1~,*e*~2~,...,*e*~n~ ，满足e~i~⋅*dst*==e~i~⋅src且 e~i~ *t**im**e*<*e**i*+1 *t**im**e* 。通过计算路径的规律性得分来确定其稀有度，得分越低越稀有。为求解最稀有路径，将问题转化为 K 最长路径问题，通过添加伪源节点和伪汇节点，并对边赋值，再将图转换为有向无环图（DAG），利用现有算法找出 K 最长路径，即 K 个最不常见的因果路径。

为筛选出最稀有的 K 条路径，引入了规律性得分（regularity score），路径R=e~1~,e~2~,e~3~.
$$
R(λ)=\sum_{i=1}^nR(e_i) \\
R(e)=OUT(src)\frac{H(e)}{H}IN(dst) \\
OUT(v)=\frac{T'_{from}}{T} \\
IN(v)=\frac{T'_{to}}{T}
$$

- OUT(*src*)：用于衡量源实体*src*对外交互的稳定性，通过计算源实体在稳定时间窗口（**无新的出边添加**）中的占比得出。
- $\frac{∣H∣}{∣H(e)∣}$：表示发生该事件的主机数量与企业中所有主机数量的比值，反映事件在不同主机上的普遍程度。
- IN(*dst*)：用于衡量目标实体*dst*接收交互的稳定性，通过计算目标实体在稳定时间窗口（**无新的入边添加**）中的占比得出。

将寻找最稀有路径的问题转化为 K 最长路径问题。规律性得分越低的路径越稀有，为让这类路径对应到最长路径，需对边进行合理赋值。

添加伪节点：给原溯源图 G 添加伪源节点*v**so**u**rce*和伪汇节点*v**s**ink*，使图成为单源单汇图，便于转化为 K 最长路径问题。伪源节点连接所有入度为 0 的节点，伪汇节点连接所有出度为 0 的节点。

边赋值：对每条边*e*赋予权重*W*(*e*)=−*l**o**g*2*R*(*e*)（*R*(*e*)为边的规律性得分），则路径的总权重为各边权重之和，即−*l**o**g*2∏*R*(*e**i*)，也就是−*l**o**g*2*R*(*λ*)（*R*(*λ*)为路径规律性得分）。此时，路径的总权重越高，对应原路径的规律性得分越低、越稀有。

> 反向评分

### 嵌入

**路径到句子的类比**：将因果路径视为 “句子”，其中节点作为 “名词”（如进程、文件、网络连接等系统实体），边作为 “动词”（如启动、读取、写入等实体间的交互关系）。

**单词序列的生成**：借助函数*l*将因果路径*λ*转化为一系列单词。对于路径中的每个事件*e~i~*，用*l*(*e~i~*.*src*)表示源节点的文本标签，*l*(*e~i~*)表示边的关系标签，*l*(*e~i~*.*dst*)表示目标节点的文本标签，依次串联形成单词序列

**PV-DM 模型的应用**：使用 PV-DM（Paragraph Vector - Distributed Memory）模型学习路径的嵌入向量。该模型将路径的单词序列作为输入，通过训练使相似路径在数值向量空间中距离更近，不同路径距离更远。同时，模型会考虑单词的顺序（如 “进程 A 启动进程 B” 与 “进程 B 启动进程 A” 在向量空间中映射不同），这对区分恶意行为至关重要（例如，正常情况下 “winword.exe 启动 cmd.exe” 与恶意情况的映射差异）。



### 异常检测

基于溯源数据的特点，PROVDETECTOR使用局部离群因子（LOF）[11]作为异常检测模型。LOF是一种基于密度的方法。如果一个点的局部密度低于其邻域点，则该点被视为离群点。LOF不对数据的概率分布做任何假设，也不使用单一曲线对数据进行分离。因此，它是解决我们异常检测问题的一种合适方法。





> 具体来说，LOF 算法通过比较数据点与其周围邻居的局部密度来识别异常。若一个数据点的局部密度显著低于其邻居的局部密度，那么该数据点就会被判定为异常点。在 PROVDETECTOR 中，经过嵌入处理的路径向量在数值空间中，相似的路径会更接近，不同的路径则相距较远。当使用 LOF 模型对这些向量进行检测时，能够有效识别出那些与正常路径向量差异较大的异常向量

## 实现

图用JAVA实现，异常用py实现

我们使用\(K=20\)所选路径作为出处图的表示。然后，我们按照\(\S V-D\)中讨论的方法，使用Gensim库[10]训练一个PV-DM模型，该模型将每条路径嵌入到一个100维的嵌入向量中，这是Gensim的默认选项。最后，我们使用这些嵌入向量，通过Scikit-learn[14]中的局部离群因子（LOF）算法训练一个异常检测模型。

## 评估

在我们的实验中，我们使用路径选择算法（§V-C1）从每个溯源图中选择前20条因果路径。然后，我们同时测量路径级别的检测准确率和图级别的检测准确率。为了测量路径级别的检测准确率，我们将每条路径视为一个单独的数据样本；对于图级别的检测准确率，我们使用基于阈值的方法（§V-E）根据路径的预测结果做出最终预测。PROVDETECTOR的检测准确率使用精确率、召回率和F1分数指标来衡量。

<img src="https://cdn.xljsci.com/literature/166634759/page9/zpddi1.png" alt="img" style="zoom:50%;" />

> 被预测为恶意的嵌入向量数量超过该阈值*t*，系统就会将对应的溯源图判定为恶意



> 在《ProvDetector.pdf》中，[56] 所引用的文献是由 W. U. Hassan 等人于 2019 年在 NDSS 会议上发表的“NoDoze: Combatting threat alert fatigue with automated provenance triage”。该文献提出的 NoDoze 是一个基于数据溯源的自动化威胁警报分类系统，其核心目的是解决威胁警报疲劳问题。 NoDoze 通过分析威胁警报相关的溯源图中因果路径的稀有性对警报进行排序，帮助安全人员优先处理更可能具有实际威胁的警报。不过，NoDoze 在处理溯源图路径时存在一定局限性，它需要枚举溯源图的所有路径才能提取出稀有路径，这在面对大型溯源图时效率较低，并且它仅能为路径提供异常分数以辅助调查，无法系统地划分良性路径和恶意路径。 而 PROVDETECTOR 在设计中借鉴了 NoDoze 中关于规律性得分的思路来识别稀有路径，但针对 NoDoze 的局限性进行了改进，提出了新的路径选择算法以高效提取稀有路径，并通过机器学习技术实现了良性与恶意路径的自动区分。