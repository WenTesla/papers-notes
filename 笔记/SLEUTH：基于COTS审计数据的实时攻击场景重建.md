## SLEUTH：基于COTS审计数据的实时攻击场景重建

## 摘要

我们提出了一种在**企业主机上实时重建攻击场景的方法和系统**。为了满足问题的可扩展性和实时需求，我们开发了一个独立于平台、基于主内存的审计日志数据依赖关系图抽象。然后，我们提出了基于标签的高效攻击检测和重建技术，包括来源识别和影响分析。我们还开发了通过构建紧凑、可视化的攻击步骤图来揭示攻击大局的方法。我们的系统参与了 DARPA 组织的红队评估，并能够成功检测并重建红队对运行 Windows、FreeBSD 和 Linux 的主机的攻击细节。

## 挑战

1. 事件存储和分析：我们如何有**效地存储事件流中的数百万条记录**，并让算法在几秒钟内筛选这些数据？

2. 确定要分析的实体的优先级：我们如何帮助被大量数据压得喘不过气来的分析师**确定优先级并快速“放大”最可能的攻击场景**？

3. 场景重构：我们如何简洁地总结攻击场景，从攻击者的切入点出发，识别整个活动对系统的影响？

4. 处理常见使用场景：如何应对可能类似于攻击期间常见活动的正常良性活动，例如软件下载？

5. 快速、交互式推理：我们如何为分析师提供有效推理数据的能力，例如，使用替代假设？

## 贡献

发了一个紧凑的主存依赖图表示（第2节），它解决了高效事件存储和分析的挑战。-- 挑战1

开发一种基于标签的方法，用于识别最有可能参与攻击的主题、对象和事件 --- 挑战2

开发利用标签进行根本原因识别和影响分析的新算法（第5节）。-- 生成的攻击图少

旨在解决上述最后两个挑战，是一个用于标签初始化和传播的可定制策略框架（第4节）

实验评估（第6节），主要基于DARPA组织的红队评估，作为其透明计算计划的一部分

## 主内存依赖图

依赖图是一种基于主机的数据结构。它可以引用其他主机上的实体，但针对主机内引用的常见情况进行了优化。该图表示两种类型的实体：主体，代表进程；以及对象，代表诸如文件、管道和网络连接之类的实体。主体属性包括进程ID（pid）、命令行、所有者以及代码和数据的标签。对象属性包括名称、类型（文件、管道、套接字等）、所有者和标签。



## 标签

出处

系统的先验知识

举止

### 标签设计

定义**信任度标签（t-tags）和机密性标签（c-tags）**，基于来源、系统先验知识和行为评估对象和主体的可信度和敏感度，用于攻击检测、优先分析和场景重建。

#### t-tags

- **良性可信(Benign authentic)标签**被分配给从被认为是良性且真实性可验证的来源接收的数据/代码。
- “**良性（Benign tag）**”标签所反映的信任程度低于“良性且可信”：虽然数据/代码仍被认为是良性的，但尚未进行充分的验证以核实其来源。 
- **“未知（Unknown）”**标签用于标记来源的可信度不明的数据/代码。此类数据有时可能存在恶意。默认标签

#### c-tags

- 机密：高度敏感的信息，如登录凭证和私钥。
- 敏感信息：其泄露会对安全产生重大影响的数据，例如，暴露系统中的漏洞，但不会为攻击者提供直接访问系统的途径。
- 私密信息：指那些公开后会涉及隐私问题，但不一定会构成安全威胁的数据。
- 公开数据：可以广泛获取的数据，例如在公共网站上的数据。

**一个主体可分为两个标签**

#### 攻击检测策略

**不受信任的代码执行**：当具有较高代码t-tag的主体执行（或加载）具有较低代码t-tag的对象时，此策略将触发警报

**低码t-tag的主体修改**：当低码t-tag的主体修改高码t-tag的对象时，该策略会发出告警。修改可能涉及文件内容或其他属性，如名称、权限等

**机密数据泄露**：当不受信任的主体泄露敏感数据时，会发出告警。具体来说，该策略是在具有敏感c标签和未知代码t标签的主体进行网络**写入**时触发的。

**不可信数据执行的准备**：如果主体的代码t标签为未知，且其操作会使对象可执行，则触发此策略。此类操作包括chmod和mprotect4,5 

> `mprotect`是一个系统调用命令，主要用于修改内存区域的保护属性，比如设置内存页为可读、可写或可执行等

## 策略

我们开发了一个灵活的策略框架，用于标签分配、传播和攻击检测。我们使用一种简单的基于规则的表示法来表达策略，
$$
exec (s, o) : o.ttag < benign \to alert ("UntrustedExec")
$$
**当主体 s 执行一个 t 标签低于良性的（文件）对象 o 时，会触发此规则。其效果是发出一个名为“UntrustedExec”的警报。**

![img](https://cdn.xljsci.com/literature/165125779/page7/epew7s.png)

> 表2：带有策略触发点的边。方向栏中，S表示主体，O表示客体。接下来的两列表示检测策略和标记设置策略的触发点。

### 初始化

这些策略在初始化触发器时被调用，用于为新对象或在审计数据中首次提及的现有对象初始化标签。请记住，当主体创建新对象时，对象**默认继承主体的标签**；但是，**可以使用标签初始化策略覆盖此默认设置**。

初始标签

```
init(o): match(o.name,"^IP:(10\.0|127)") →o.ttag = BENIGN AUTH,o.ctag = PRIVATE // 内网
init(o): match(o.name,"^IP:") →o.ttag = UNKNOWN,o.ctag = PRIVATE // 公网
init(o): o.type == FILE→o.ttag = BENIGN AUTH,o.ctag = PUBLIC
```

用于标记企业内网或本地连接，默认视为可信，但需保护其隐私数据

公网 IP 连接默认视为不可信，需重点监控其数据交互，避免敏感信息泄露

为系统中的文件设置默认标签，减少正常文件操作的误报，同时为后续异常修改（如不可信进程修改文件）提供检测基础。

这些初始化规则是标签系统的起点，后续标签会通过`read`、`write`等事件的传播策略动态更新。例如：

- 若一个`IP:10.0.0.1`的网络连接（初始标签`BENIGN_AUTH`）被不可信进程读取，则其标签可能被降级；
- 若一个文件（初始标签`PUBLIC`）被写入敏感数据，则其机密性标签可能升级为`SENSITIVE`或`SECRET`。

### 标签传播

标签传播策略可用于防止“过度污染”，这种情况可能由诸如.bash历史记录之类的文件导致，**应用程序每次调用时都会反复读取和写入这些文件**。以下策略将跳过对此特定文件的污染传播：

```
propRd(s,o): match(o.name,"\.bash_history$") → skip	
```



```
propRd(s,o): match(s.cmdline,"^/bin/bash$") →s.code ttag = s.data ttag = o.ttag, s.ctag = o.ctag
```



此外，当登录阶段完成时（通常通过执行setuid操作来标识），应该为进程分配适当的标记

```
propSu(s): match(s.cmdline,"^/usr/sbin/sshd$") →s.code ttag = s.data ttag = BENIGN, s.ctag = PRIVATE
```

## 双向分析

### 挑战

- 性能：边很多
- 多路径：通常，从一个可疑节点可以向后访问许多入口点

#### 成本函数

**成本 0**：若边连接 “未知标签节点” 与 “良性标签节点”，表示恶意与良性的边界，必须包含在搜索路径中。

**成本高（如∞）**：若边连接两个良性标签节点，说明是正常业务流，排除在攻击路径外。

**成本 1**：若边连接两个未知标签节点，说明是攻击链内部的依赖，优先度低于边界边但高于良性边。

> 若边从 “未知标签进程” 指向 “良性标签文件”，成本为 0；若边从 “良性标签进程” 指向 “良性标签文件”，成本为∞，算法不会选择该路径。

**算法选择**：使用 Dijkstra 算法，按**成本递增**顺序探索路径，一旦找到入口点即停止搜索。

#### 重构

**修剪无趣的节点**。前向分析的结果可能包括许多与攻击无关的依赖项，例如，主题写入缓存和日志文件，或者写入临时文件然后将其删除。这些节点可能出现在前向分析的结果中，但没有可疑节点依赖于它们，因此可以修剪它们。

**合并具有相同名称的实体**。这种简化合并了具有相同名称的主体，忽略了它们的进程ID和命令行参数。

**重复事件过滤**。这种简化将同一实体之间发生多次（例如，多次写入、多次读取）的事件合并为一个。如果有交错事件，那么我们显示两个事件，表示两个实体之间事件的第一次和最后一次发生

## 实验



总的数据集的概述

![img](https://cdn.xljsci.com/literature/165125779/page12/ai575d.png)

我们在本节中讨论活动W-2（Windows）和F-3（FreeBSD）

![w2](https://cdn.xljsci.com/literature/165125779/page11/sn3vvv.png)

### 良性环境

我们在 3 到 5 天内从四个 Ubuntu Linux 服务器收集了审计数据。**其中一个是邮件服务器，另一个是 Web 服务器，第三个是 NFS/SSH/SVN 服务器**。在此期间，我们的重点是**软件更新和升级**，因为这些更新可以从网络下载代码，从而增加不受信任的代码执行警报的可能性。在此期间，执行了四次安全更新（包括内核更新）。此外，在第四台服务器上，我们在执行软件升级时收集了数据，导致 110 个软件包发生了变化。在此期间更新了数千个二进制文件和脚本文件，审核日志包含超过 30M 个事件。表 8 总结了所有这些信息。

如前所述，应将策略配置为允许使用企业中批准的标准方法进行软件更新和升级。对于 Ubuntu Linux，我们对此有一个策略规则：当 dpkg 由 apt-commands 或 unattended-upgrades 执行时，即使从具有不受信任的标签的文件中读取，该进程也不会降级。这是因为 apt 和 unattended-upgrades 都会验证和验证下载的软件包的哈希值，只有在这些验证之后，它们才会调用 dpkg 来提取内容并写入包含二进制文件和库的各种目录。由于此策略，下载的所有 10K+ 文件都标记为良性。因此，SLEUTH 执行这些作时不会生成任何警报。

![img](https://cdn.xljsci.com/literature/165125779/page13/qdsrom.png)

期间没有警告

### 处理时间

![img](https://cdn.xljsci.com/literature/165125779/page13/u8rvgy.png)

### d-tag和c-tag的拆分

| **标签类型**   | **定义**                                               | **核心目的**                                                 |
| -------------- | ------------------------------------------------------ | ------------------------------------------------------------ |
| **code t-tag** | 标识进程所执行代码的信任度（如代码是否来自可信来源）。 | 检测 “不可信代码执行” 类攻击（如恶意脚本加载、后门程序启动）。 |
| **data t-tag** | 标识进程处理数据的信任度（如数据是否来自可信来源）。   | 检测 “数据污染” 类攻击（如敏感数据泄露、恶意输入注入）。     |

ddd





### 对比

SLEUTH 在两个重要方面改进了 Backtracker 的技术。首先，Backtracker 旨在在取证环境中运行，而我们的分析和数据表示技术旨在实现实时检测。撇开硬件比较不谈，我们注意到 Bactracker 花了 3 个小时来分析 audit 数据，而 SLEUTH 能够在不到 3 分钟的时间内处理 358 小时的日志。其次，Backtracker 依赖于外部工具生成的警报，因此其取证搜索和修剪无法利用生成这些警报的原因。相比之下，我们的分析程序利用了我们原则性的基于标签的检测方法的结果，因此本质上更加精确。例如，如果攻击故意写入已知的日志文件，Backtracker 的搜索启发式可能会从最终图表中删除日志文件，而我们基于标签的分析将防止该节点被修剪掉。





## 评价

基于标签的学习，工作量大，没有用到机器学习

不开源





